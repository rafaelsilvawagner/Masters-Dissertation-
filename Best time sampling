#Esse código funcionará da forma que você define um nivel de agregação minima do datafrae, segundos, minutos, horas
#você devera informar o intervalo de agregação (de 1 min a 60 min)
#observe que ele devolve um vetor onde a diferença das linhas não é o intervalo de agregação tipo 5 minustos,  mas sim a agregação min
#ou seja quando você solicitar o intervalo de 5 minutos todas as linhas somarão os evento de até 5 min atras mas isso sera feito de 1 em 1 minutos
#esse código está montado de uma maneira que ele monta os dataframe, executa o logit e o xgboost, e te devolve a precisão geral
#além disso ele te devolve algumas caracteristicas especificas das classes 1 e 3  como sensitividade e especificadade

#precisamos desses pacotes
library(GetHFData)
library(plyr)
library(dplyr)
library(lubridate)
library(chron)
library(tictoc)
library(data.table)
library(xgboost)
library(caret)
library(mlogit)
library(zoo)
library(SDMTools)

#Defina os ativos e o tipo de mercado que você irá analisar
assets=c("PETR4","VALE5","ABEV3")
number_assets=length(assets)
type.market="equity"
#Os futuros começamas 09 ja a bovespa começa as 10, eu não quero dados de after market por isso peço dados de até 17:00
first.time <- '10:00:00'
last.time <- '17:00:00'
#Verifica quais são as datas que você ja tem  arquivos disponibilizados pela bolsa
contents<-ghfd_get_ftp_contents(type.market="equity")
#Define quanto dos ultimos dias atualizados você vai querer
trading_days<-5
last.date<-tail(contents$dates,1)
first.date<-contents$dates[nrow(contents)-trading_days]
dates<-contents$dates[which(contents$dates == last.date):which(contents$dates == first.date)]
#Define o nivel de agregação e o tipo de agregação máxima que você vai querer
agregação_maxima=5
tipo_agregacao="min"
resumo<-data.frame(matrix(nrow=agregação_maxima,ncol=29),row.names=1:agregação_maxima)

colnames(resumo)<-c("Sensitivity buy","Specificity buy","Pos Pred Value buy","Neg Pred Value buy"
                    ,"Precision buy","Recall buy","F1 buy","Prevalence buy",
                    "Detection Rate  buy","Detection Prevalence buy","Balanced Accuracy buy",
                    "Sensitivity sell","Specificity sell","Pos Pred Value sell","Neg Pred Value sell"
                    ,"Precision sell","Recall sell","F1 sell","Prevalence sell",
                    "Detection Rate sell","Detection Prevalence sell","Balanced Accuracy sell",
                    "Accuracy","Kappa","AccuracyLower","AccuracyUpper","AccuracyNull",
                    "AccuracyPValue","McnemarPValue")


#você vai fazer a análise um ativo de cada vez
for (round_assets in 1:number_assets) {
  asset<-assets[round_assets]
  #faz pra uma dada agregação
  for(agregacao in 1:trading_days){
    #todos os dias
    for(round in 1:agregação_maxima) {
        date<-dates[round]
        time<-"1 sec"
        #############################
        ##Pega Dados
        ############################
        
        
        #Get trades data by raw
        if(file.exists(sprintf("H://treated_variables//times and trades//agg//%s//%s//%s.csv",time,asset,date))){
          trades_agg_1sec <- read.csv(sprintf("H://treated_variables//times and trades//agg//%s//%s//%s.csv",time,asset,date),header=TRUE)
          trades_agg_1sec<- trades_agg_1sec[1:nrow(trades_agg_1sec)-1,2:ncol(trades_agg_1sec)]
        } else {trades_agg_1sec<-ghfd_get_HF_data(my.assets=asset,type.market=type.market,type.data="trades",
          first.date=date,last.date=date,type.output="agg",agg.diff = time,
          first.time =first.time,last.time =last.time,
          dl.dir = "H://ftp.bmf.com.br//MarketData//Bovespa-Vista")
          write.csv(trades_agg_1sec,sprintf("H://treated_variables//times and trades//agg//%s//%s//%s.csv",time,asset,date))
        }
          
        #Get trades data aggregated
        if(file.exists(sprintf("H://treated_variables//times and trades//raw//%s//%s//%s.csv",time,asset,date))){
          trades_raw <- read.csv(sprintf("H://treated_variables//times and trades//raw//%s//%s//%s.csv",time,asset,date))
          trades_raw<-trades_raw[,2:ncol(trades_raw)]
        } else {trades_raw<-ghfd_get_HF_data(my.assets=asset,type.market=type.market,type.data="trades",
          first.date=date,last.date=date,type.output="raw",agg.diff = time,
          first.time =first.time,last.time =last.time,
          dl.dir = "H://ftp.bmf.com.br//MarketData//Bovespa-Vista")
          write.csv(trades_raw,sprintf("H://treated_variables//times and trades//raw//%s//%s//%s.csv",time,asset,date))
        }
          
        
        #############################
        ##Transforma Dados Temporalmente
        ############################
        #coloca TradeTime em chron
        trades_raw$Tradetime<-chron(times=trades_raw$Tradetime)
        trades_agg_1sec$Tradetime<-chron(times=trades_agg_1sec$Tradetime)
        
        #coloca TradeDateTime em Posix
        trades_raw$TradeDateTime<-as.POSIXct(trades_raw$TradeDateTime)
        trades_agg_1sec$TradeDateTime<-as.POSIXct(trades_agg_1sec$TradeDateTime)
        
        #define o tipo de agregacao minima que sera usada
        agregacao_minima<-sprintf("1 %s",tipo_agregacao)
        #Controi o vetor que servirá de base para todos os outros
        sequencia_temporal=seq(from=(round.POSIXt(as.POSIXct(paste(date,first(trades_agg_1sec$Tradetime))),"mins")+agregacao*60-60),
                               to=as.POSIXct(paste(date,last(trades_agg_1sec$Tradetime))),
                               by=agregacao_minima)
        
        trades_agg<-data.frame(matrix(0, nrow = length(sequencia_temporal), ncol = ncol(trades_agg_1sec)))
        rownames(trades_agg)<-sequencia_temporal
        colnames(trades_agg)<-colnames(trades_agg_1sec)
        
        #preenche as variáveis com relação a estrutura temporal
        trades_agg$InstrumentSymbol<-asset
        trades_agg$SessionDate<-date
        trades_agg$TradeDateTime<-sequencia_temporal
        trades_agg$Tradetime<-chron(times=strftime(sequencia_temporal, format="%H:%M:%S"))
        
        #cria uma nova variável chamada segundos desde as 09:00:00
        trades_agg$time_opening<-as.numeric(trades_agg$TradeDateTime)-
                                              as.numeric(as.POSIXct(paste(date,"09:00:00")))
        
        
    
        ############################################
        ####Preenche aquelas variáveis que já existiam
        ############################################
       
    
        #cria uma coluna pra guardaar 4 variáveis que criaremos
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"vol.buys"
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"vol.sells"
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"weighted.price.buys"    
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"weighted.price.sells"
        
        #recupera as informações tomando como base o times and trades por linha
  
        for (i in 2:nrow(trades_agg)){
          if(nrow(subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[i] &
                         TradeDateTime>(trades_agg$TradeDateTime[i-1]-agregacao*60+60)))>0){
            subcon<-subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[i] &
                             TradeDateTime>(trades_agg$TradeDateTime[i-1]-(agregacao*60)+60))
            trades_agg$n.trades[i]<-nrow(subcon)
            trades_agg$sum.qtd[i]<-sum(subcon$TradedQuantity)
            trades_agg$sum.vol[i]<-sum(subcon$TradedQuantity*subcon$TradePrice)
            trades_agg$last.price[i]<-last(subcon$TradePrice)
            #recupera a volatilidade pondedrada
            if(nrow(subcon)>1){
              trades_agg$period.ret.volat[i]<-wt.var(x=subcon$TradePrice,wt=subcon$TradedQuantity)
              }
            #recupera buys
            if(nrow(subset(subcon,TradeSign==1))>0){
              trades_agg$n.buys[i]<-nrow(subset(subcon,TradeSign==1))
              trades_agg$vol.buys[i]<-sum(subset(subcon,TradeSign==1)["TradePrice"]*subset(subcon,TradeSign==1)["TradedQuantity"])
              trades_agg$weighted.price.buys[i]<-wt.mean(x=subset(subcon,TradeSign==1)$TradePrice,wt=subset(subcon,TradeSign==1)$TradedQuantity)
            }
            #recupera sells
            if(nrow(subset(subcon,TradeSign==-1))>0){
              trades_agg$n.sells[i]<-nrow(subset(subcon,TradeSign==-1))
              trades_agg$vol.sells[i]<-sum(subset(subcon,TradeSign==-1)["TradePrice"]*subset(subcon,TradeSign==-1)["TradedQuantity"])
              trades_agg$weighted.price.sells[i]<-wt.mean(x=subset(subcon,TradeSign==-1)$TradePrice,wt=subset(subcon,TradeSign==-1)$TradedQuantity)
            }
            rm(subcon)
          }
        }
  
        #cria o preço ponderado
        trades_agg$weighted.price<-trades_agg$sum.vol/trades_agg$sum.qtd
        trades_agg$weighted.price[is.nan(trades_agg$weighted.price)]=0
        
        #no last.price faz a ultima observação se carregada para as próximas
        trades_agg$last.price[2:nrow(trades_agg)]<-na.locf(with(trades_agg, 
                                            ifelse(last.price == 0, NA_real_, last.price)))
        
        #Preenche os valores da primeira linha
        if(nrow(subset(trades_raw,TradeDateTime==trades_agg$TradeDateTime[1]))>0){
          subcon<-subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[1])
          trades_agg$n.trades[1]<-nrow(subcon)
          trades_agg$sum.qtd[1]<-sum(subcon$TradedQuantity)
          trades_agg$sum.vol[1]<-sum(subcon$TradedQuantity*subcon$TradePrice)
          trades_agg$last.price[1]<-last(subcon$TradePrice)
          #recupera a volatilidade pondedrada
          if(nrow(subcon)>1){
            trades_agg$period.ret.volat[1]<-wt.var(x=subcon$TradePrice,wt=subcon$TradedQuantity)
          }
          #recupera buys
          if(nrow(subset(subcon,TradeSign==1))>0){
            trades_agg$n.buys[1]<-nrow(subset(subcon,TradeSign==1))
            trades_agg$vol.buys[1]<-sum(subset(subcon,TradeSign==1)["TradePrice"]*subset(subcon,TradeSign==1)["TradedQuantity"])
            trades_agg$weighted.price.buys[1]<-wt.mean(x=subset(subcon,TradeSign==1)$TradePrice,wt=subset(subcon,TradeSign==1)$TradedQuantity)
          }
          #recupera sells
          if(nrow(subset(subcon,TradeSign==-1))>0){
            trades_agg$n.sells[1]<-nrow(subset(subcon,TradeSign==-1))
            trades_agg$vol.sells[1]<-sum(subset(subcon,TradeSign==-1)["TradePrice"]*subset(subcon,TradeSign==-1)["TradedQuantity"])
            trades_agg$weighted.price.sells[1]<-wt.mean(x=subset(subcon,TradeSign==-1)$TradePrice,wt=subset(subcon,TradeSign==-1)$TradedQuantity)
          }
          rm(subcon)
        }
        
        #cria o preço ponderado
        trades_agg$weighted.price<-trades_agg$sum.vol/trades_agg$sum.qtd
        trades_agg$weighted.price[is.nan(trades_agg$weighted.price)]=0
        
        if (trades_agg[1,4]==0){
        #no last.price faz a ultima observação se carregada para as próximas
        trades_agg$last.price[2:nrow(trades_agg)]<-
          na.locf(with(trades_agg,ifelse(last.price == 0, NA_real_, last.price)))
        }else{
          trades_agg$last.price<-na.locf(with(trades_agg,ifelse(last.price == 0, NA_real_, last.price)))
        }
        #retorno no período
        if(trades_agg[1,4]==0){
        trades_agg$period.ret[3:nrow(trades_agg)]<-(trades_agg$last.price[3:(nrow(trades_agg))]/
                                                      trades_agg$last.price[2:(nrow(trades_agg)-1)])-1
        }else{trades_agg$period.ret[2:nrow(trades_agg)]<-(trades_agg$last.price[2:nrow(trades_agg)]/
                                                            trades_agg$last.price[1:nrow(trades_agg)-1])-1}
        ############################
        #PEGA O BOOK
        ############################
        
        #Get book data aggregated
        if(file.exists(sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date))){
          book_agg <- read.csv(sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date),header=TRUE)
        } else {book_agg<-ghfd_get_HF_data(my.assets=asset,type.market=type.market,type.data="orders",
                          first.date=date,last.date=date,type.output="agg",agg.diff=time,
                          first.time =first.time,last.time =last.time,
                          dl.dir = "H://ftp.bmf.com.br//MarketData//Bovespa-Vista")
                write.csv(book_agg,sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date))
        }
        
        date_trades<-trades_agg$Tradetime
        date_trades<-chron(times=date_trades)
        date_book<-book_agg$OrderDatetime
        date_book<-format(strptime(date_book,"%Y-%m-%d %H:%M:%S"),'%H:%M:%S')
        book_agg$OrderDatetime<-as.POSIXct(book_agg$OrderDatetime)
        date_book<-chron(times=date_book)
  
        book_agg<-cbind(book_agg[1:(nrow(book_agg)/2),],
                        book_agg[((nrow(book_agg)/2)+1):nrow(book_agg),])
        book_agg<-book_agg[,c(4,5,6,7,8,10,11,12,17,18,19,20,22,23,24)]
        names(book_agg)[1:15]<-c("OrderDatetime","n.order.buy", "avg.order.price.buy","max.order.price.buy",
                                     "min.order.price.buy","n.new.order.buy","n.update.order.buy",
                                     "n.cancelled.order.buy",
                                     "n.order.sell", "avg.order.price.sell","max.order.price.sell",
                                     "min.order.price.sell","n.new.order.sell","n.update.order.sell",
                                     "n.cancelled.order.sell")
          
        ###CONTROI O VETOR QUE AGREGARÁ OS DADOS DO BOOK
        book_agregado<-data.frame(matrix(0, nrow = length(sequencia_temporal), ncol = ncol(book_agg)))
        rownames(book_agregado)<-sequencia_temporal
        colnames(book_agregado)<-colnames(book_agg)
        book_agregado$OrderDatetime<-as.POSIXct(sequencia_temporal)
  
        
        ##############################
        #preenche as colunas com as variáveis que já existiam
        #############################
        for (i in 2:nrow(book_agregado)){
          if(nrow(subset(book_agg,OrderDatetime<=book_agregado$OrderDatetime[i] &
                         OrderDatetime>(book_agregado$OrderDatetime[i-1]+60-60*agregacao)))>0){
            
            subcon<-subset(book_agg,OrderDatetime<=book_agregado$OrderDatetime[i] &
                             OrderDatetime>book_agregado$OrderDatetime[i-1]+60-60*agregacao)
            
            for (j in 2:ncol(book_agregado)){
              book_agregado[i,j]<-sum(subcon[,j])
            }
            
            
            book_agregado$avg.order.price.buy[i]<-weighted.mean(subcon$avg.order.price.buy,subcon$n.order.buy)
            book_agregado$max.order.price.buy[i]<-max(subcon$avg.order.price.buy)
            book_agregado$min.order.price.buy[i]<-min(subcon$avg.order.price.buy)
            book_agregado$avg.order.price.sell[i]<-weighted.mean(subcon$avg.order.price.buy,subcon$n.order.sell)
            book_agregado$max.order.price.sell[i]<-max(subcon$avg.order.price.sell)
            book_agregado$min.order.price.sell[i]<-min(subcon$avg.order.price.sell)
          }
        }
        
        #Preenche a primeira linha
        if(nrow(subset(book_agg,OrderDatetime<=book_agregado$OrderDatetime[1] &
                       OrderDatetime>(book_agregado$OrderDatetime[1]+60-60*agregacao-60))>0)){
          
          subcon<-subset(book_agg,OrderDatetime<=book_agregado$OrderDatetime[1] &
                           OrderDatetime>book_agregado$OrderDatetime[1]+60-60*agregacao-60)
          
          for (j in 2:ncol(book_agregado)){
            book_agregado[1,j]<-sum(subcon[,j])
          }
          
          
          book_agregado$avg.order.price.buy[1]<-weighted.mean(subcon$avg.order.price.buy,subcon$n.order.buy)
          book_agregado$max.order.price.buy[1]<-max(subcon$avg.order.price.buy)
          book_agregado$min.order.price.buy[1]<-min(subcon$avg.order.price.buy)
          book_agregado$avg.order.price.sell[1]<-weighted.mean(subcon$avg.order.price.buy,subcon$n.order.sell)
          book_agregado$max.order.price.sell[1]<-max(subcon$avg.order.price.sell)
          book_agregado$min.order.price.sell[1]<-min(subcon$avg.order.price.sell)
        }
        
        
        
        ##############################
      
        #preenche os buracos
        book_agregado$n.order.buy[is.na(book_agregado$n.order.buy)] <- 0
        book_agregado$n.order.sell[is.na(book_agregado$n.order.sell)] <- 0
        
        book_agregado$avg.order.price.sell[is.na(book_agregado$avg.order.price.sell)] <- 0
        book_agregado$avg.order.price.buy[is.na(book_agregado$avg.order.price.buy)] <- 0
        book_agregado$max.order.price.buy[is.na(book_agregado$max.order.price.buy)] <- 0      
        book_agregado$max.order.price.sell[is.na(book_agregado$max.order.price.sell)] <- 0
        book_agregado$min.order.price.buy[is.na(book_agregado$min.order.price.buy)] <- 0
        book_agregado$min.order.price.sell[is.na(book_agregado$min.order.price.sell)] <- 0
              
        book_agregado$n.new.order.buy[is.na(book_agregado$n.new.order.buy)] <- 0
        book_agregado$n.update.order.buy[is.na(book_agregado$n.update.order.buy)] <- 0
        book_agregado$n.cancelled.order.buy[is.na(book_agregado$n.cancelled.order.buy)] <- 0      
        book_agregado$n.new.order.sell[is.na(book_agregado$n.new.order.sell)] <- 0
        book_agregado$n.update.order.sell[is.na(book_agregado$n.update.order.sell)] <- 0
        book_agregado$n.cancelled.order.sell[is.na(book_agregado$n.cancelled.order.sell)] <- 0          
        
        para_defasar<-data.frame(cbind(trades_agg,book_agregado[,2:ncol(book_agregado)]))[,-13]
        
  
      
        
        
        #######################
        #DEFASA
        ######################
        intervalo <- 0.0001 # retornos no intervalo <(-intervalo,+intervalo)> são label 1, menores são 0 e maiores são 2
        
        signal <- cut(para_defasar$period.ret,breaks=c(-Inf,-intervalo,intervalo,Inf),labels=c(0,1,2)) # multinomial signal
        dados<-cbind(signal,para_defasar)
        # matriz de regressores defasados
        max.lags <- 4
        T <- dim(dados)[1]
        N <- dim(dados)[2]
        nao_defasar_primeiras<-5
        for (i in 1:max.lags){
          ifelse(i==1,
                 lag.matrix <- dados[i:(T-max.lags+i-1),nao_defasar_primeiras:N],
                 lag.matrix <- cbind(lag.matrix,dados[i:(T-max.lags+i-1),nao_defasar_primeiras:N]))
        }
        colnames(lag.matrix) <- paste0(colnames(dados[,5:N]),'.lag.',rep(max.lags:1, each=(N-nao_defasar_primeiras-1)))
        # Vetor de variável dependente atual
        direction<-as.matrix(as.numeric(signal))[(max.lags+1):T,]
        completa<-cbind(direction,lag.matrix)


  
      #Junta tudo em uma matriz final
      if (exists("final_product")) {
        final_product<-rbind(final_product,completa)
      } else {
        final_product<-completa
      }
      
    }
    
    
    # Define dados de treino (50%) e validação (50%)
    train <- 1:round(0.8*T)
    train.reg <- as.matrix(final_product[train,-1])
    train.signal <- as.matrix(final_product[train,1])-1
    valid.reg <- as.matrix(final_product[-train,-1])
    valid.signal <- as.matrix(final_product[-train,1])-1

    
    
    dtrain = xgb.DMatrix(data = train.reg, label = train.signal)
    numberOfClasses <- length(unique(signal))
    ##############################
    
    
    xgb_params <- list("objective" = "multi:softprob",
                       "eval_metric" = "mlogloss",
                       "num_class" = numberOfClasses)
    nround    <- 100 # number of XGBoost rounds
    cv.nfold  <- 5
    # Fit cv.nfold * cv.nround XGB models and save OOF predictions
    cv_model <- xgb.cv(params = xgb_params,
                       data = dtrain, 
                       nrounds = nround,
                       nfold = cv.nfold,
                       verbose = FALSE,
                       prediction = TRUE)
    best<-which(min(log(cv_model$evaluation_log$test_mlogloss_mean))==log(cv_model$evaluation_log$test_mlogloss_mean))
    
    #OOF_prediction <- data.frame(cv_model$pred) %>%
    #  mutate(max_prob = max.col(., ties.method = "last"),
    #         label = as.numeric(train.signal) + 1)
    #head(OOF_prediction)
    
    
    # confusion matrix
    #confusionMatrix(factor(OOF_prediction$label), 
    #                factor(OOF_prediction$max_prob),
    #                mode = "everything")
    
    
    ####
    # Modelo xgboost para classificação multinomial
    ####
    
    xgb_params <- list("objective" = "multi:softprob",
                       "eval_metric" = "mlogloss",
                       "num_class" = numberOfClasses)
    xgModel = xgb.train(params = xgb_params,
                        data = dtrain, 
                        nround = best)
    xgboost.predict <- predict(xgModel, valid.reg)
    test_prediction <- matrix(xgboost.predict, nrow = numberOfClasses,
                              ncol=length(xgboost.predict)/numberOfClasses) %>%
      t() %>%
      data.frame() %>%
      mutate(label = as.numeric(valid.signal) + 1,
             max_prob = max.col(., "last"))
    c <- confusionMatrix(factor(test_prediction$label),
                         factor(test_prediction$max_prob),
                         mode = "everything")
    #print(c)
    #names <-  colnames(lag.matrix)
    #importance_matrix = xgb.importance(feature_names = names, model = xgModel)
    #gp = xgb.plot.importance(importance_matrix)
    #print(gp)
    colnames(resumo)<-colnames(c$byClass)
    resumo[agregacao,1:11]<-c$byClass[1,1:11]
    resumo[agregacao,12:22]<-c$byClass[3,1:11]
    resumo[agregacao,23:29]<-c$overall
  }
  #Fazer estimação
}


