#Esse código funcionará da forma que você define um nivel de agregação minima do datafrae, segundos, minutos, horas
#você devera informar o intervalo de agregação (de 1 min a 60 min)
#observe que ele devolve um vetor onde a diferença das linhas não é o intervalo de agregação tipo 5 minustos,  mas sim a agregação min
#ou seja quando você solicitar o intervalo de 5 minutos todas as linhas somarão os evento de até 5 min atras mas isso sera feito de 1 em 1 minutos
#esse código está montado de uma maneira que ele monta os dataframe, executa o logit e o xgboost, e te devolve a precisão geral
#além disso ele te devolve algumas caracteristicas especificas das classes 1 e 3  como sensitividade e especificadade

#precisamos desses pacotes
library(GetHFData)
library(plyr)
library(dplyr)
library(lubridate)
library(chron)
library(tictoc)
library(data.table)
library(zoo)
library(SDMTools)

#Defina os ativos e o tipo de mercado que você irá analisar
assets=c("PETR4","VALE5","ABEV3")
number_assets=length(assets)
type.market="equity"
#Os futuros começamas 09 ja a bovespa começa as 10, eu não quero dados de after market por isso peço dados de até 17:00
first.time <- '10:00:00'
last.time <- '17:00:00'
#Verifica quais são as datas que você ja tem  arquivos disponibilizados pela bolsa
contents<-ghfd_get_ftp_contents(type.market="equity")
#Define quanto dos ultimos dias atualizados você vai querer
trading_days<-100
last.date<-tail(contents$dates,1)
first.date<-contents$dates[nrow(contents)-trading_days]
dates<-contents$dates[which(contents$dates == last.date):which(contents$dates == first.date)]
#Define o nivel de agregação e o tipo de agregação máxima que você vai querer
agregação_maxima=60
tipo_agregacao="min"



#você vai fazer a análise um ativo de cada vez
for (round_assets in 1:number_assets) {
  asset<-assets[round_assets]

  #pra cada ativo você vai começar fazer para o numero de dias que você ja definiu
  for(round in 1:trading_days) {
      date<-dates[round]
      time<-"1 sec"
      #############################
      ##Pega Dados
      ############################
      
      
      #Get trades data by raw
      if(file.exists(sprintf("H://treated_variables//times and trades//agg//%s//%s//%s.csv",time,asset,date))){
        trades_agg_1sec <- read.csv(sprintf("H://treated_variables//times and trades//agg//%s//%s//%s.csv",time,asset,date),header=TRUE)
        trades_agg_1sec<- trades_agg_1sec[1:nrow(trades_agg_1sec)-1,2:ncol(trades_agg_1sec)]
      } else {trades_agg_1sec<-ghfd_get_HF_data(my.assets=asset,type.market=type.market,type.data="trades",
        first.date=date,last.date=date,type.output="agg",agg.diff = time,
        first.time =first.time,last.time =last.time,
        dl.dir = "H://ftp.bmf.com.br//MarketData//Bovespa-Vista")
        write.csv(trades_agg_1sec,sprintf("H://treated_variables//times and trades//agg//%s//%s//%s.csv",time,asset,date))
      }
        
      #Get trades data aggregated
      if(file.exists(sprintf("H://treated_variables//times and trades//raw//%s//%s//%s.csv",time,asset,date))){
        trades_raw <- read.csv(sprintf("H://treated_variables//times and trades//raw//%s//%s//%s.csv",time,asset,date))
        trades_raw<-trades_raw[,2:ncol(trades_raw)]
      } else {trades_raw<-ghfd_get_HF_data(my.assets=asset,type.market=type.market,type.data="trades",
        first.date=date,last.date=date,type.output="raw",agg.diff = time,
        first.time =first.time,last.time =last.time,
        dl.dir = "H://ftp.bmf.com.br//MarketData//Bovespa-Vista")
        write.csv(trades_raw,sprintf("H://treated_variables//times and trades//raw//%s//%s//%s.csv",time,asset,date))
      }
        
      
      #############################
      ##Transforma Dados Temporalmente
      ############################
      #coloca TradeTime em chron
      trades_raw$Tradetime<-chron(times=trades_raw$Tradetime)
      trades_agg_1sec$Tradetime<-chron(times=trades_agg_1sec$Tradetime)
      
      #coloca TradeDateTime em Posix
      trades_raw$TradeDateTime<-as.POSIXct(trades_raw$TradeDateTime)
      trades_agg_1sec$TradeDateTime<-as.POSIXct(trades_agg_1sec$TradeDateTime)
      
      #define o tipo de agregacao minima que sera usada
      agregacao_minima<-sprintf("1 %s",tipo_agregacao)
      #Controi o vetor que servirá de base para todos os outros
      sequencia_temporal=seq(from=as.POSIXct(paste(date,first(trades_agg_1sec$Tradetime))),
                             to=as.POSIXct(paste(date,last(trades_agg_1sec$Tradetime))),
                             by=agregacao_minima)
      
      trades_agg<-data.frame(matrix(0, nrow = length(sequencia_temporal), ncol = ncol(trades_agg_1sec)))
      rownames(trades_agg)<-sequencia_temporal
      colnames(trades_agg)<-colnames(trades_agg_1sec)
      
      #preenche as variáveis com relação a estrutura temporal
      trades_agg$InstrumentSymbol<-asset
      trades_agg$SessionDate<-date
      trades_agg$TradeDateTime<-sequencia_temporal
      trades_agg$Tradetime<-chron(times=strftime(sequencia_temporal, format="%H:%M:%S"))
      
      #cria uma nova variável chamada segundos desde as 09:00:00
      trades_agg$time_opening<-as.numeric(trades_agg$TradeDateTime)-
                                            as.numeric(as.POSIXct(paste(date,"09:00:00")))
      
      
  
      ############################################
      ####Preenche aquelas variáveis que já existiam
      ############################################
     
  
      #cria uma coluna pra guardaar 4 variáveis que criaremos
      
      trades_agg[,ncol(trades_agg)+1]=0
      names(trades_agg)[ncol(trades_agg)]<-"vol.buys"
      
      trades_agg[,ncol(trades_agg)+1]=0
      names(trades_agg)[ncol(trades_agg)]<-"vol.sells"
      
      trades_agg[,ncol(trades_agg)+1]=0
      names(trades_agg)[ncol(trades_agg)]<-"weighted.price.buys"    
      
      trades_agg[,ncol(trades_agg)+1]=0
      names(trades_agg)[ncol(trades_agg)]<-"weighted.price.sells"
      
      #recupera as informações tomando como base o times and trades por linha

      for (i in 2:nrow(trades_agg)){
        if(nrow(subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[i] &
                       TradeDateTime>trades_agg$TradeDateTime[i-1]))>0){
          subcon<-subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[i] &
                           TradeDateTime>trades_agg$TradeDateTime[i-1])
          trades_agg$n.trades[i]<-nrow(subcon)
          trades_agg$sum.qtd[i]<-sum(subcon$TradedQuantity)
          trades_agg$sum.vol[i]<-sum(subcon$TradedQuantity*subcon$TradePrice)
          trades_agg$last.price[i]<-last(subcon$TradePrice)
          #recupera a volatilidade pondedrada
          if(nrow(subcon)>1){
            trades_agg$period.ret.volat[i]<-wt.var(x=subcon$TradePrice,wt=subcon$TradedQuantity)
            }
          #recupera buys
          if(nrow(subset(subcon,TradeSign==1))>0){
            trades_agg$n.buys[i]<-nrow(subset(subcon,TradeSign==1))
            trades_agg$vol.buys[i]<-sum(subset(subcon,TradeSign==1)["TradePrice"]*subset(subcon,TradeSign==1)["TradedQuantity"])
            trades_agg$weighted.price.buys[i]<-wt.mean(x=subset(subcon,TradeSign==1)$TradePrice,wt=subset(subcon,TradeSign==1)$TradedQuantity)
          }
          #recupera sells
          if(nrow(subset(subcon,TradeSign==-1))>0){
            trades_agg$n.sells[i]<-nrow(subset(subcon,TradeSign==-1))
            trades_agg$vol.sells[i]<-sum(subset(subcon,TradeSign==-1)["TradePrice"]*subset(subcon,TradeSign==-1)["TradedQuantity"])
            trades_agg$weighted.price.sells[i]<-wt.mean(x=subset(subcon,TradeSign==-1)$TradePrice,wt=subset(subcon,TradeSign==-1)$TradedQuantity)
          }
          rm(subcon)
        }
      }

      #cria o preço ponderado
      trades_agg$weighted.price<-trades_agg$sum.vol/trades_agg$sum.qtd
      trades_agg$weighted.price[is.nan(trades_agg$weighted.price)]=0
      
      #no last.price faz a ultima observação se carregada para as próximas
      trades_agg$last.price[2:nrow(trades_agg)]<-na.locf(with(trades_agg, 
                                          ifelse(last.price == 0, NA_real_, last.price)))
      
      #Preenche os valores da primeira linha
      if(nrow(subset(trades_raw,TradeDateTime==trades_agg$TradeDateTime[1]))>0){
        subcon<-subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[1])
        trades_agg$n.trades[1]<-nrow(subcon)
        trades_agg$sum.qtd[1]<-sum(subcon$TradedQuantity)
        trades_agg$sum.vol[1]<-sum(subcon$TradedQuantity*subcon$TradePrice)
        trades_agg$last.price[1]<-last(subcon$TradePrice)
        #recupera a volatilidade pondedrada
        if(nrow(subcon)>1){
          trades_agg$period.ret.volat[1]<-wt.var(x=subcon$TradePrice,wt=subcon$TradedQuantity)
        }
        #recupera buys
        if(nrow(subset(subcon,TradeSign==1))>0){
          trades_agg$n.buys[1]<-nrow(subset(subcon,TradeSign==1))
          trades_agg$vol.buys[1]<-sum(subset(subcon,TradeSign==1)["TradePrice"]*subset(subcon,TradeSign==1)["TradedQuantity"])
          trades_agg$weighted.price.buys[1]<-wt.mean(x=subset(subcon,TradeSign==1)$TradePrice,wt=subset(subcon,TradeSign==1)$TradedQuantity)
        }
        #recupera sells
        if(nrow(subset(subcon,TradeSign==-1))>0){
          trades_agg$n.sells[1]<-nrow(subset(subcon,TradeSign==-1))
          trades_agg$vol.sells[1]<-sum(subset(subcon,TradeSign==-1)["TradePrice"]*subset(subcon,TradeSign==-1)["TradedQuantity"])
          trades_agg$weighted.price.sells[1]<-wt.mean(x=subset(subcon,TradeSign==-1)$TradePrice,wt=subset(subcon,TradeSign==-1)$TradedQuantity)
        }
        rm(subcon)
      }
      
      #cria o preço ponderado
      trades_agg$weighted.price<-trades_agg$sum.vol/trades_agg$sum.qtd
      trades_agg$weighted.price[is.nan(trades_agg$weighted.price)]=0
      
      #no last.price faz a ultima observação se carregada para as próximas
      trades_agg$last.price<-na.locf(with(trades_agg,ifelse(last.price == 0, NA_real_, last.price)))
      
      #retorno no período
      trades_agg$period.ret[2:nrow(trades_agg)]<-(trades_agg$last.price[2:nrow(trades_agg)]/
                                                    trades_agg$last.price[1:nrow(trades_agg)-1])-1
      
      ###3#########################
      #PEGA O BOOK
      ############################
      
      #Get book data aggregated
      if(file.exists(sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date))){
        book_agg <- read.csv(sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date),header=TRUE)
      } else {book_agg<-ghfd_get_HF_data(my.assets=asset,type.market=type.market,type.data="orders",
                        first.date=date,last.date=date,type.output="agg",agg.diff=time,
                        first.time =first.time,last.time =last.time,
                        dl.dir = "H://ftp.bmf.com.br//MarketData//Bovespa-Vista")
              write.csv(book_agg,sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date))
      }
      
      date_trades<-trades_agg$Tradetime
      date_trades<-chron(times=date_trades)
      date_book<-book_agg$OrderDatetime
      date_book<-format(strptime(date_book,"%Y-%m-%d %H:%M:%S"),'%H:%M:%S')
      book_agg$OrderDatetime<-as.POSIXct(book_agg$OrderDatetime)
      date_book<-chron(times=date_book)

      book_agg<-cbind(book_agg[1:(nrow(book_agg)/2),],
                      book_agg[((nrow(book_agg)/2)+1):nrow(book_agg),])
      book_agg<-book_agg[,c(4,5,6,7,8,10,11,12,17,18,19,20,22,23,24)]
      names(book_agg)[1:15]<-c("OrderDatetime","n.order.buy", "avg.order.price.buy","max.order.price.buy",
                                   "min.order.price.buy","n.new.order.buy","n.update.order.buy",
                                   "n.cancelled.order.buy",
                                   "n.order.sell", "avg.order.price.sell","max.order.price.sell",
                                   "min.order.price.sell","n.new.order.sell","n.update.order.sell",
                                   "n.cancelled.order.sell")
        
      ###CONTROI O VETOR QUE AGREGARÁ OS DADOS DO BOOK
      book_agregado<-data.frame(matrix(0, nrow = length(sequencia_temporal), ncol = ncol(book_agg)))
      rownames(book_agregado)<-sequencia_temporal
      colnames(book_agregado)<-colnames(book_agg)
      book_agregado$OrderDatetime<-as.POSIXct(sequencia_temporal)

      
      ##############################
      #preenche as colunas com as variáveis que já existiam
      #############################
      for (i in 2:nrow(book_agregado)){
        if(nrow(subset(book_agg,OrderDatetime<=book_agregado$OrderDatetime[i] &
                       OrderDatetime>book_agregado$OrderDatetime[i-1]))>0){
          
          subcon<-subset(book_agg,OrderDatetime<=book_agregado$OrderDatetime[i] &
                           OrderDatetime>book_agregado$OrderDatetime[i-1])
          
          for (j in 2:ncol(book_agregado)){
            book_agregado[i,j]<-sum(subcon[,j])
          }
          
          
          book_agregado$avg.order.price.buy[i]<-weighted.mean(subcon$avg.order.price.buy,subcon$n.order.buy)
          book_agregado$max.order.price.buy[i]<-max(subcon$avg.order.price.buy)
          book_agregado$min.order.price.buy[i]<-min(subcon$avg.order.price.buy)
          book_agregado$avg.order.price.sell[i]<-weighted.mean(subcon$avg.order.price.buy,subcon$n.order.sell)
          book_agregado$max.order.price.sell[i]<-max(subcon$avg.order.price.sell)
          book_agregado$min.order.price.sell[i]<-min(subcon$avg.order.price.sell)
        }
      }
      
      #Preenche a primeira linha
      if(nrow(subset(book_agg,OrderDatetime<=book_agregado$OrderDatetime[1] &
                     OrderDatetime>(book_agregado$OrderDatetime[1]-60))>0)){
        
        subcon<-subset(book_agg,OrderDatetime<=book_agregado$OrderDatetime[1] &
                         OrderDatetime>book_agregado$OrderDatetime[1]-60)
        
        for (j in 2:ncol(book_agregado)){
          book_agregado[1,j]<-sum(subcon[,j])
        }
        
        
        book_agregado$avg.order.price.buy[1]<-weighted.mean(subcon$avg.order.price.buy,subcon$n.order.buy)
        book_agregado$max.order.price.buy[1]<-max(subcon$avg.order.price.buy)
        book_agregado$min.order.price.buy[1]<-min(subcon$avg.order.price.buy)
        book_agregado$avg.order.price.sell[1]<-weighted.mean(subcon$avg.order.price.buy,subcon$n.order.sell)
        book_agregado$max.order.price.sell[1]<-max(subcon$avg.order.price.sell)
        book_agregado$min.order.price.sell[1]<-min(subcon$avg.order.price.sell)
      }
      
      
      
      ##############################
    
      #preenche os buracos
      book_agregado$n.order.buy[is.na(book_agregado$n.order.buy)] <- 0
      book_agregado$n.order.sell[is.na(book_agregado$n.order.sell)] <- 0
      
      book_agregado$avg.order.price.sell[is.na(book_agregado$avg.order.price.sell)] <- 0
      book_agregado$avg.order.price.buy[is.na(book_agregado$avg.order.price.buy)] <- 0
      book_agregado$max.order.price.buy[is.na(book_agregado$max.order.price.buy)] <- 0      
      book_agregado$max.order.price.sell[is.na(book_agregado$max.order.price.sell)] <- 0
      book_agregado$min.order.price.buy[is.na(book_agregado$min.order.price.buy)] <- 0
      book_agregado$min.order.price.sell[is.na(book_agregado$min.order.price.sell)] <- 0
            
      book_agregado$n.new.order.buy[is.na(book_agregado$n.new.order.buy)] <- 0
      book_agregado$n.update.order.buy[is.na(book_agregado$n.update.order.buy)] <- 0
      book_agregado$n.cancelled.order.buy[is.na(book_agregado$n.cancelled.order.buy)] <- 0      
      book_agregado$n.new.order.sell[is.na(book_agregado$n.new.order.sell)] <- 0
      book_agregado$n.update.order.sell[is.na(book_agregado$n.update.order.sell)] <- 0
      book_agregado$n.cancelled.order.sell[is.na(book_agregado$n.cancelled.order.sell)] <- 0          
      
      defasada<-cbind(trades_agg,book_agregado[,2:ncol(book_agregado)])
      
        #######################
        #DEFASA
        ######################
        defasada<-cbind(trades_agg,book_agg)
        intervalo <- 0.01 # retornos no intervalo <(-intervalo,+intervalo)> são label 1, menores são 0 e maiores são 2
        
        signal <- cut(defasada$period.ret,breaks=c(-Inf,-intervalo,intervalo,Inf),labels=c(0,1,2)) # multinomial signal
        dados<-cbind(signal,defasada)
        # matriz de regressores defasados
        max.lags <- 10
        T <- dim(dados)[1]
        N <- dim(dados)[2]
        nao_defasar_primeiras<-4
        for (i in 1:max.lags){
          ifelse(i==1,
                 lag.matrix <- dados[i:(T-max.lags+i-1),nao_defasar_primeiras:N],
                 lag.matrix <- cbind(lag.matrix,dados[i:(T-max.lags+i-1),nao_defasar_primeiras:N]))
        }
        colnames(lag.matrix) <- paste0(colnames(dados[,5:N]),'.lag.',rep(max.lags:1, each=(N-nao_defasar_primeiras-1)))
        # Vetor de variável dependente atual
        actuals <- as.matrix(signal)
        actuals <- actuals[(max.lags+1):T,1]
        completa<-merge(actuals,lag.matrix)
        
        #####ATENÇÃO
        
        for(agregacao in 1:agregação_maxima){
          agregacao=1
          time<-sprintf("%x min",agregacao)
          if (file.exists(sprintf("H://treated_variables//book//agg//%s//%s",time,asset))){
            write.csv(final_product,sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date))
          }else{
            #Tem que criar uma função que crie a pasta se ela não existir
            write.csv(final_product,sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date))
          }
        }
          

          
          #####ATENÇÃO

        rm(trades_raw)
        rm(trades_agg)
        rm(book_agg)
    }
  
  #Junta tudo em uma matriz final
  if (agregacao=1){
    final_product<-rbind(actuals,lag.matrix)
  }
  if (exists("final_product")) {
    final_product<-rbind(actuals,lag.matrix)
  } else {
    final_product<-cbind(trades_agg,book_agg[,3:ncol(book_agg)])
  }
  
    write.csv(final_product,sprintf("C://Users//rwagn//Documents//Dissertacao de Mestrado//teste2_%s.csv",asset,agregacao))
    #Junta tudo em uma matriz final
    if (agregacao=1){
    rm(final_product)
}
