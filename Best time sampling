#Esse código funcionará da forma que você define um nivel de agregação minima do datafrae, segundos, minutos, horas
#você devera informar o intervalo de agregação (de 1 min a 60 min)
#observe que ele devolve um vetor onde a diferença das linhas não é o intervalo de agregação tipo 5 minustos,  mas sim a agregação min
#ou seja quando você solicitar o intervalo de 5 minutos todas as linhas somarão os evento de até 5 min atras mas isso sera feito de 1 em 1 minutos
#esse código está montado de uma maneira que ele monta os dataframe, executa o logit e o xgboost, e te devolve a precisão geral
#além disso ele te devolve algumas caracteristicas especificas das classes 1 e 3  como sensitividade e especificadade

#precisamos desses pacotes
library(GetHFData)
library(plyr)
library(dplyr)
library(lubridate)
library(Weighted.Desc.Stat)
library(chron)
library(ggplot2)
library(tictoc)
library(data.table)
library(xgboost)
library(caret)
library(mlogit)
library(zoo)
library(SDMTools)

#Defina os ativos e o tipo de mercado que você irá analisar
assets=c("PETR4","VALE5","ABEV3")
number_assets=length(assets)
type.market="equity"

#Os futuros começam as 09 ja a bovespa começa as 10, eu não quero dados de after market por isso peço dados de até 17:00
first.time <- '10:00:00'
last.time <- '17:00:00'

#Verifica quais são as datas que você ja tem  arquivos disponibilizados pela bolsa
contents<-ghfd_get_ftp_contents(type.market="equity")
#Define quanto dos ultimos dias atualizados você vai querer
trading_days<-100
#aponta o primeiro e o ultimo dia de analise
last.date<-tail(contents$dates,1)
first.date<-contents$dates[nrow(contents)-trading_days]
dates<-contents$dates[which(contents$dates == last.date):which(contents$dates == first.date)]

#Define o nivel de agregação e o tipo de agregação máxima que você vai querer
agregacao_maxima=60
tipo_agregacao="mins"
#salto define a diferença de tempo de uma linha pra outra no data frame em segundos
agregacao_minima<-sprintf("1 %s",tipo_agregacao)
#salto é a agregacao_minima em segundos
salto=60

resumo<-data.frame(matrix(nrow=agregacao_maxima,ncol=29),row.names=1:agregacao_maxima)

colnames(resumo)<-c("Sensitivity buy","Specificity buy","Pos Pred Value buy","Neg Pred Value buy"
                    ,"Precision buy","Recall buy","F1 buy","Prevalence buy",
                    "Detection Rate  buy","Detection Prevalence buy","Balanced Accuracy buy",
                    "Sensitivity sell","Specificity sell","Pos Pred Value sell","Neg Pred Value sell"
                    ,"Precision sell","Recall sell","F1 sell","Prevalence sell",
                    "Detection Rate sell","Detection Prevalence sell","Balanced Accuracy sell",
                    "Accuracy","Kappa","AccuracyLower","AccuracyUpper","AccuracyNull",
                    "AccuracyPValue","McnemarPValue")


#você vai fazer a análise um ativo de cada vez
for (round_assets in 1:number_assets) {
  asset<-assets[round_assets]
  #faz pra uma dada agregação
  for(agregacao in 1:agregacao_maxima){
    #todos os dias
    for(round in 1:trading_days) {
      print(paste(asset,agregacao,round))  
      date<-dates[round]
        time<-"1 sec"
        #############################
        ##Pega Dados
        ############################
        #Get trades data by raw
        if(file.exists(sprintf("H://treated_variables//times and trades//agg//%s//%s//%s.csv",time,asset,date))){
          trades_agg_1sec <- read.csv(sprintf("H://treated_variables//times and trades//agg//%s//%s//%s.csv",time,asset,date),header=TRUE)
          trades_agg_1sec<- trades_agg_1sec[1:nrow(trades_agg_1sec)-1,2:ncol(trades_agg_1sec)]
        } else {trades_agg_1sec<-ghfd_get_HF_data(my.assets=asset,type.market=type.market,type.data="trades",
          first.date=date,last.date=date,type.output="agg",agg.diff = time,
          first.time =first.time,last.time =last.time,
          dl.dir = "H://ftp.bmf.com.br//MarketData//Bovespa-Vista")
          write.csv(trades_agg_1sec,sprintf("H://treated_variables//times and trades//agg//%s//%s//%s.csv",time,asset,date))
        }
          
        #Get trades data aggregated
        if(file.exists(sprintf("H://treated_variables//times and trades//raw//%s//%s//%s.csv",time,asset,date))){
          trades_raw <- read.csv(sprintf("H://treated_variables//times and trades//raw//%s//%s//%s.csv",time,asset,date))
          trades_raw<-trades_raw[,2:ncol(trades_raw)]
        } else {trades_raw<-ghfd_get_HF_data(my.assets=asset,type.market=type.market,type.data="trades",
          first.date=date,last.date=date,type.output="raw",agg.diff = time,
          first.time =first.time,last.time =last.time,
          dl.dir = "H://ftp.bmf.com.br//MarketData//Bovespa-Vista")
          write.csv(trades_raw,sprintf("H://treated_variables//times and trades//raw//%s//%s//%s.csv",time,asset,date))
        }
          
        
        #############################
        ##Transforma Dados Temporalmente
        ############################
        #coloca TradeTime em chron
        trades_raw$Tradetime<-chron(times=trades_raw$Tradetime)
        trades_agg_1sec$Tradetime<-chron(times=trades_agg_1sec$Tradetime)
        
        
        #coloca TradeDateTime em Posix
        trades_raw$TradeDateTime<-as.POSIXct(trades_raw$TradeDateTime)
        trades_agg_1sec$TradeDateTime<-as.POSIXct(trades_agg_1sec$TradeDateTime)
        
        #Controi o vetor que servirá de base para todos os outros
        sequencia_temporal=seq(from=(round.POSIXt(as.POSIXct(paste(date,first(trades_agg_1sec$Tradetime))),tipo_agregacao)+agregacao*salto),
                               to=as.POSIXct(paste(date,last(trades_agg_1sec$Tradetime))),
                               by=agregacao_minima)
        
        trades_agg<-data.frame(matrix(0, nrow = length(sequencia_temporal), ncol = ncol(trades_agg_1sec)))
        rownames(trades_agg)<-sequencia_temporal
        colnames(trades_agg)<-colnames(trades_agg_1sec)
        
        #preenche as variáveis com relação a estrutura temporal
        trades_agg$InstrumentSymbol<-asset
        trades_agg$SessionDate<-date
        trades_agg$TradeDateTime<-sequencia_temporal
        trades_agg$Tradetime<-chron(times=strftime(sequencia_temporal, format="%H:%M:%S"))
        
        #cria uma nova variável chamada segundos desde as 09:00:00
        trades_agg$time_opening<-as.numeric(trades_agg$TradeDateTime)-
                                              as.numeric(as.POSIXct(paste(date,"09:00:00")))
        
        
    

        #cria colunas pra guardar 4 variáveis que criaremos do Times and Trades
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"vol.buys"
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"vol.sells"
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"weighted.price.buys"    
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"weighted.price.sells"
        
        #cria colunas pra guardar 4 variáveis que criaremos do book
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"MeanReturn" 
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"VarianceReturn" 
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"SkewnessReturn"    
        
        trades_agg[,ncol(trades_agg)+1]=0
        names(trades_agg)[ncol(trades_agg)]<-"KurtosisReturn"
        
        names(trades_agg)[8]<-"period.price.volat"
        
        #Preenche os valores da primeira linha
        if(nrow(subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[1]))>0){
          subcon<-subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[1])
          
          #preenche as variáveis mais simples
          #o numero de negócios é o numero de linhas
          trades_agg$n.trades[1]<-nrow(subcon)
          #o volume de cada negócio está na coluna TradedQuantity, se você somá-la voce tera a quantidade negociada
          trades_agg$sum.qtd[1]<-sum(subcon$TradedQuantity)
          #tendo a quantidade negociada e sabendo o preço que cada uma foi negociada podemos chegar ao volume negociado
          trades_agg$sum.vol[1]<-sum(subcon$TradedQuantity*subcon$TradePrice)
          #o ultimo preço dessa linha será o ultimo preço negociado no período
          trades_agg$last.price[1]<-last(subcon$TradePrice)
          #o preço ponderado são os preços ponderados pela respectiva quantidade negociada
          trades_agg$weighted.price[1]<-wt.mean(x=(subcon$TradePrice),wt=subcon$TradedQuantity)
          #aqui vale um aviso eu troquei o significado de uma colune
          trades_agg$period.price.volat[1]<-wt.var(x=(subcon$TradePrice),wt=subcon$TradedQuantity)
          
          
          #recupera os 4 primeiros momentos do retorno no período
          open_price<-first(subcon$TradePrice)
          trades_agg$period.ret[1]<-(last(subcon$TradePrice)/open_price)-1
          if(nrow(subcon)>1){
            trades_agg$MeanReturn[1]<-wt.mean(x=((subcon$TradePrice/open_price)-1),wt=subcon$TradedQuantity)
          }
          if(nrow(subcon)>1){
            trades_agg$VarianceReturn[1]<-wt.var(x=((subcon$TradePrice/open_price)-1),wt=subcon$TradedQuantity)
          }
          if(nrow(subcon)>1){
            trades_agg$SkewnessReturn[1]<-w.skewness(x=(subcon$TradePrice/open_price-1),mu=subcon$TradedQuantity)
          }
          if(nrow(subcon)>1){
            trades_agg$KurtosisReturn[1]<-w.kurtosis(x=(subcon$TradePrice/open_price-1),mu=subcon$TradedQuantity)
          }
          
          #recupera buys
          if(nrow(subset(subcon,TradeSign==1))>0){
            trades_agg$n.buys[1]<-nrow(subset(subcon,TradeSign==1))
            trades_agg$vol.buys[1]<-sum(subset(subcon,TradeSign==1)["TradePrice"]*subset(subcon,TradeSign==1)["TradedQuantity"])
            trades_agg$weighted.price.buys[1]<-wt.mean(x=subset(subcon,TradeSign==1)$TradePrice,wt=subset(subcon,TradeSign==1)$TradedQuantity)
          }
          #recupera sells
          if(nrow(subset(subcon,TradeSign==-1))>0){
            trades_agg$n.sells[1]<-nrow(subset(subcon,TradeSign==-1))
            trades_agg$vol.sells[1]<-sum(subset(subcon,TradeSign==-1)["TradePrice"]*subset(subcon,TradeSign==-1)["TradedQuantity"])
            trades_agg$weighted.price.sells[1]<-wt.mean(x=subset(subcon,TradeSign==-1)$TradePrice,wt=subset(subcon,TradeSign==-1)$TradedQuantity)
          }
          rm(subcon)
        }
        
        
        #recupera as informações tomando como base o times and trades por linha
        for (i in 2:nrow(trades_agg)){
          if(nrow(subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[i] &
                         TradeDateTime>(trades_agg$TradeDateTime[i-1]-agregacao*salto+salto)))>0){
            
            subcon<-subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[i] &
                             TradeDateTime>(trades_agg$TradeDateTime[i-1]-(agregacao*salto)+salto))
            
            trades_agg$n.trades[i]<-nrow(subcon)
            trades_agg$sum.qtd[i]<-sum(subcon$TradedQuantity)
            trades_agg$sum.vol[i]<-sum(subcon$TradedQuantity*subcon$TradePrice)
            trades_agg$last.price[i]<-last(subcon$TradePrice)
            trades_agg$weighted.price[i]<-wt.mean(x=(subcon$TradePrice),wt=subcon$TradedQuantity)
            trades_agg$period.price.volat[i]<-wt.var(x=(subcon$TradePrice),wt=subcon$TradedQuantity)
            
            #define o preço referencia
            last_price<-last(subset(trades_raw,TradeDateTime<=trades_agg$TradeDateTime[i]-agregacao*salto)$TradePrice)
            trades_agg$period.ret[i]<-(last(subcon$TradePrice)/last_price)-1
            
            #recupera os primeiros 4 primeiros momentos dos retornos
            if(nrow(subcon)>1){
              trades_agg$MeanReturn[i]<-wt.mean(x=((subcon$TradePrice/last_price)-1),wt=subcon$TradedQuantity)
            }
            if(nrow(subcon)>1){
              trades_agg$VarianceReturn[i]<-wt.var(x=((subcon$TradePrice/last_price)-1),wt=subcon$TradedQuantity)
            }
            if(nrow(subcon)>1){
              trades_agg$SkewnessReturn[i]<-w.skewness(x=(subcon$TradePrice/last_price-1),mu=subcon$TradedQuantity)
            }
            if(nrow(subcon)>1){
              trades_agg$KurtosisReturn[i]<-w.kurtosis((x=subcon$TradePrice/last_price-1),mu=subcon$TradedQuantity)
            }
            
          
            #recupera buys
            if(nrow(subset(subcon,TradeSign==1))>0){
              trades_agg$n.buys[i]<-nrow(subset(subcon,TradeSign==1))
              trades_agg$vol.buys[i]<-sum(subset(subcon,TradeSign==1)["TradePrice"]*subset(subcon,TradeSign==1)["TradedQuantity"])
              trades_agg$weighted.price.buys[i]<-wt.mean(x=subset(subcon,TradeSign==1)$TradePrice,wt=subset(subcon,TradeSign==1)$TradedQuantity)
            }
            #recupera sells
            if(nrow(subset(subcon,TradeSign==-1))>0){
              trades_agg$n.sells[i]<-nrow(subset(subcon,TradeSign==-1))
              trades_agg$vol.sells[i]<-sum(subset(subcon,TradeSign==-1)["TradePrice"]*subset(subcon,TradeSign==-1)["TradedQuantity"])
              trades_agg$weighted.price.sells[i]<-wt.mean(x=subset(subcon,TradeSign==-1)$TradePrice,wt=subset(subcon,TradeSign==-1)$TradedQuantity)
            }
            rm(subcon)
          } else {
            trades_agg$last.price[i]<-last(trades_agg$last.price[trades_agg$last.price!=0])
          }
        }
  
        


        ############################
        #PEGA O BOOK
        ############################
        
        #Get book data aggregated
        if(file.exists(sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date))){
          book_agg_1sec <- read.csv(sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date),header=TRUE)
        } else {book_agg_1sec<-ghfd_get_HF_data(my.assets=asset,type.market=type.market,type.data="orders",
                          first.date=date,last.date=date,type.output="agg",agg.diff=time,
                          first.time =first.time,last.time =last.time,
                          dl.dir = "H://ftp.bmf.com.br//MarketData//Bovespa-Vista")
                write.csv(book_agg_1sec,sprintf("H://treated_variables//book//agg//%s//%s//%s.csv",time,asset,date))
        }
        if(colnames(book_agg_1sec)[1]=="X"){
          book_agg_1sec<-book_agg_1sec[,-1]
        }
        book_agg_1sec<-book_agg_1sec[,c(-1,-2)]
        
        ###CONTROI O VETOR QUE AGREGARÁ OS DADOS DO BOOK
        book_agg<-data.frame(matrix(0, nrow = length(sequencia_temporal), ncol = 15))
        rownames(book_agg)<-sequencia_temporal
        colnames(book_agg)<-c("OrderDatetime",paste(colnames(book_agg_1sec)[c(-1,-6)],".buy",sep=""),
                              paste(colnames(book_agg_1sec)[c(-1,-6)],".sell",sep=""))
        book_agg_1sec$OrderDatetime<-as.POSIXct(book_agg_1sec$OrderDatetime)
        book_agg$OrderDatetime<-as.POSIXct(sequencia_temporal)
  
        
        ##############################
        #preenche as colunas com as variáveis que já existiam
        #############################
      
        
        #Preenche a primeira linha
        if(nrow(subset(book_agg_1sec,OrderDatetime<=book_agg$OrderDatetime[1]&
                       OrderDatetime>book_agg$OrderDatetime[1]-agregacao*salto))>0){
          
          if(nrow(subset(book_agg_1sec,OrderDatetime<=book_agg$OrderDatetime[1] &
                    OrderDatetime>book_agg$OrderDatetime[1]-agregacao*salto &
                    type.order=="Buy"))>0){
            
             subcon_buy<-subset(book_agg_1sec,OrderDatetime<=book_agg$OrderDatetime[1] &
                               OrderDatetime>book_agg$OrderDatetime[1]-agregacao*salto &
                               type.order=="Buy")
             
             book_agg$n.order.buy[1]<-sum(subcon_buy$n.order)
             book_agg$n.new.order.buy[1]<-sum(subcon_buy$n.new.order)
             book_agg$n.update.order.buy[1]<-sum(subcon_buy$n.update.order)
             book_agg$n.cancelled.order.buy[1]<-sum(subcon_buy$n.cancelled.order)
             book_agg$avg.order.price.buy[1]<-weighted.mean(subcon_buy$avg.order.price,subcon_buy$n.order)
             book_agg$max.order.price.buy[1]<-max(subcon_buy$max.order.price)
             book_agg$min.order.price.buy[1]<-min(subcon_buy$min.order.price)
          }
          
          if(nrow(subset(book_agg_1sec,OrderDatetime<=book_agg$OrderDatetime[1] &
                        OrderDatetime>book_agg$OrderDatetime[1]-agregacao*salto &
                        type.order=="Sell"))>0){
            
            subcon_sell<-subset(book_agg_1sec,OrderDatetime<=book_agg$OrderDatetime[1] &
                                  OrderDatetime>book_agg$OrderDatetime[1]-agregacao*salto &
                                  type.order=="Sell")
            
            book_agg$n.order.sell[1]<--sum(subcon_sell$n.order)
            book_agg$n.new.order.sell[1]<-sum(subcon_sell$n.new.order)
            book_agg$n.update.order.sell[1]<-sum(subcon_sell$n.update.order)
            book_agg$n.cancelled.order.sell[1]<-sum(subcon_sell$n.cancelled.order)
            book_agg$avg.order.price.sell[1]<-weighted.mean(subcon_sell$avg.order.price,subcon_sell$n.order)
            book_agg$min.order.price.sell[1]<-min(subcon_sell$min.order.price)
            book_agg$max.order.price.sell[1]<-max(subcon_sell$max.order.price)
          }
        }
        
        
        for (i in 2:nrow(book_agg)){
          if(nrow(subset(book_agg_1sec,OrderDatetime<=book_agg$OrderDatetime[i] &
                         OrderDatetime>(book_agg$OrderDatetime[i-1]+salto-salto*agregacao)))>0){
            
            
            if (nrow(subcon_buy<-subset(book_agg_1sec,OrderDatetime<=book_agg$OrderDatetime[i] &
                                        OrderDatetime>(book_agg$OrderDatetime[i-1]+salto-salto*agregacao) &
                                        type.order=="Buy"))>0){
              
              subcon_buy<-subset(book_agg_1sec,OrderDatetime<=book_agg$OrderDatetime[i] &
                             OrderDatetime>book_agg$OrderDatetime[i-1]+salto-salto*agregacao &
                             type.order=="Buy")
              
              book_agg$n.order.buy[i]<-sum(subcon_buy$n.order)
              book_agg$n.new.order.buy[i]<-sum(subcon_buy$n.new.order)
              book_agg$n.update.order.buy[i]<-sum(subcon_buy$n.update.order)
              book_agg$n.cancelled.order.buy[i]<-sum(subcon_buy$n.cancelled.order)
              book_agg$avg.order.price.buy[i]<-weighted.mean(subcon_buy$avg.order.price,subcon_buy$n.order)
              book_agg$max.order.price.buy[i]<-max(subcon_buy$max.order.price)
              book_agg$min.order.price.buy[i]<-min(subcon_buy$min.order.price)
            }
            
            if (nrow(subcon_sell<-subset(book_agg_1sec,OrderDatetime<=book_agg$OrderDatetime[i] &
                                         OrderDatetime>(book_agg$OrderDatetime[i-1]+salto-salto*agregacao) &
                                         type.order=="Sell"))>0){
          
            subcon_sell<-subset(book_agg_1sec,OrderDatetime<=book_agg$OrderDatetime[i] &
                                  OrderDatetime>book_agg$OrderDatetime[i-1]+salto-salto*agregacao&
                                type.order=="Sell")
            
            book_agg$n.order.sell[i]<-sum(subcon_sell$n.order)
            book_agg$n.new.order.sell[i]<-sum(subcon_sell$n.new.order)
            book_agg$n.update.order.sell[i]<-sum(subcon_sell$n.update.order)
            book_agg$n.cancelled.order.sell[i]<-sum(subcon_sell$n.cancelled.order)
            book_agg$avg.order.price.sell[i]<-weighted.mean(subcon_sell$avg.order.price,subcon_sell$n.order)
            book_agg$max.order.price.sell[i]<-max(subcon_sell$max.order.price)
            book_agg$min.order.price.sell[i]<-min(subcon_sell$min.order.price)
            }
          }
        }
        
        
        
        
        #junta o times and trades e o book
        
        para_defasar<-data.frame(cbind(trades_agg,book_agg))
        para_defasar<-para_defasar[,-which(names(para_defasar) %in% c("OrderDatetime","Tradetime"))]
      
        
        
        #######################
        #DEFASA
        ######################
        intervalo <- 0.0001 # retornos no intervalo <(-intervalo,+intervalo)> são label 1, menores são 0 e maiores são 2
        
        
        signal <- as.numeric(cut(para_defasar$period.ret,breaks=c(-Inf,-intervalo,intervalo,Inf),labels=c(0,1,2))) # multinomial signal
        dados<-cbind(signal,para_defasar)
        # matriz de regressores defasados
        max.lags <- 4

        
        defasada<-dados[(max.lags*agregacao+1):nrow(dados),]
        defasada<-defasada[,-which(names(defasada) %in% c("InstrumentSymbol","SessionDate","TradeDateTime"))]
        names<-colnames(defasada)
        
        for(i in 1:max.lags){
          def<-dados[((max.lags-i)*agregacao+1):(nrow(dados)-i*agregacao),
                     -which(names(dados) %in% c("InstrumentSymbol","SessionDate","TradeDateTime"))]
          colnames(def)<-paste(names,"defasagem",i,sep=".")
          defasada<-cbind(defasada,def)
        }
        
        # Vetor de variável dependente atual
        direction<-as.matrix(as.numeric(signal))[(max.lags*agregacao+1+1):nrow(dados),]
        completa<-cbind(direction,defasada[-1,])


  
      #Junta tudo em uma matriz final
      if (exists("final_product")) {
        final_product<-rbind(final_product,completa)
      } else {
        final_product<-completa
      }
      
    }
    
    #retira o symbolo a data da sessão e o horarios
    treinar<-final_product
    
    # Define dados de treino (50%) e validação (50%)
    train <- 1:round(0.8*nrow(treinar))
    train.reg <- as.matrix(treinar[train,-1])
    train.signal <- as.matrix(treinar[train,1])-1
    valid.reg <- as.matrix(treinar[-train,-1])
    valid.signal <- as.matrix(treinar[-train,1])-1

    
    
    
    dtrain = xgb.DMatrix(data = train.reg, label = train.signal)
    
    numberOfClasses <- length(unique(signal))
    ##############################
    
    
    xgb_params <- list("objective" = "multi:softprob",
                       "eval_metric" = "mlogloss",
                       "num_class" = numberOfClasses)
    nround    <- 50 # number of XGBoost rounds
    cv.nfold  <- 5
    # Fit cv.nfold * cv.nround XGB models and save OOF predictions
    cv_model <- xgb.cv(params = xgb_params,
                       data = dtrain, 
                       nrounds = nround,
                       nfold = cv.nfold,
                       verbose = FALSE,
                       prediction = TRUE)
    best<-which(min(log(cv_model$evaluation_log$test_mlogloss_mean))==log(cv_model$evaluation_log$test_mlogloss_mean))
    
    #OOF_prediction <- data.frame(cv_model$pred) %>%
    #  mutate(max_prob = max.col(., ties.method = "last"),
    #         label = as.numeric(train.signal) + 1)
    #head(OOF_prediction)
    
    
    # confusion matrix
    #confusionMatrix(factor(OOF_prediction$label), 
    #                factor(OOF_prediction$max_prob),
    #                mode = "everything")
    
    
    ####
    # Modelo xgboost para classificação multinomial
    ####
    
    xgb_params <- list("objective" = "multi:softprob",
                       "eval_metric" = "mlogloss",
                       "num_class" = numberOfClasses)
    xgModel = xgb.train(params = xgb_params,
                        data = dtrain, 
                        nround = best)
    xgboost.predict <- predict(xgModel, valid.reg)
    test_prediction <- matrix(xgboost.predict, nrow = numberOfClasses,
                              ncol=length(xgboost.predict)/numberOfClasses) %>%
      t() %>%
      data.frame() %>%
      mutate(label = as.numeric(valid.signal) + 1,
             max_prob = max.col(., "last"))
    c <- confusionMatrix(factor(test_prediction$label),
                         factor(test_prediction$max_prob),
                         mode = "everything")
    print(c)
    #names <-  colnames(lag.matrix)
    #importance_matrix = xgb.importance(feature_names = names, model = xgModel)
    #gp = xgb.plot.importance(importance_matrix)
    #print(gp)
    
    resumo[agregacao,1:11]<-t(c$byClass[1,1:11])
    resumo[agregacao,12:22]<-t(c$byClass[3,1:11])
    resumo[agregacao,23:29]<-t(c$overall)
    
    rm(final_product)
  }
  #Fazer estimação
}

par(mfrow=c(3,2))
plot.ts(resumo["Sensitivity buy"])
plot.ts(resumo["Sensitivity sell"])
plot.ts(resumo["Specificity buy"])
plot.ts(resumo["Specificity sell"])
plot.ts(resumo["Precision buy"])
plot.ts(resumo["Precision sell"])

        
